import 'package:serverpod/serverpod.dart';
import '../generated/protocol.dart';

class CollectionEndpoint extends Endpoint {
  /// Create a new collection
  Future<Collection> createCollection(
    Session session,
    String name, {
    String? description,
  }) async {
    final userId = await _getUserId(session);

    final collection = Collection(
      userId: userId,
      name: name,
      description: description,
      isAutoGenerated: false,
      createdAt: DateTime.now(),
    );

    return await Collection.db.insertRow(session, collection);
  }

  /// Get all collections for the user
  Future<List<Collection>> getCollections(Session session) async {
    final userId = await _getUserId(session);

    return await Collection.db.find(
      session,
      where: (t) => t.userId.equals(userId),
      orderBy: (t) => t.createdAt,
      orderDescending: true,
    );
  }

  /// Get a single collection with its captures
  Future<Collection?> getCollection(
    Session session,
    int collectionId,
  ) async {
    final userId = await _getUserId(session);

    return await Collection.db.findFirstRow(
      session,
      where: (t) => t.id.equals(collectionId) & t.userId.equals(userId),
    );
  }

  /// Get captures in a collection
  Future<List<Capture>> getCollectionCaptures(
    Session session,
    int collectionId,
  ) async {
    final userId = await _getUserId(session);

    // Verify user owns the collection
    final collection = await Collection.db.findFirstRow(
      session,
      where: (t) => t.id.equals(collectionId) & t.userId.equals(userId),
    );

    if (collection == null) {
      return [];
    }

    // Get capture IDs from join table
    final captureCollections = await CaptureCollection.db.find(
      session,
      where: (t) => t.collectionId.equals(collectionId),
      orderBy: (t) => t.addedAt,
      orderDescending: true,
    );

    final captureIds = captureCollections.map((cc) => cc.captureId).toList();

    if (captureIds.isEmpty) {
      return [];
    }

    // Get captures
    return await Capture.db.find(
      session,
      where: (t) => t.id.inSet(captureIds.toSet()),
    );
  }

  /// Add a capture to a collection
  Future<bool> addCaptureToCollection(
    Session session,
    int captureId,
    int collectionId,
  ) async {
    final userId = await _getUserId(session);

    // Verify user owns both the capture and collection
    final capture = await Capture.db.findFirstRow(
      session,
      where: (t) => t.id.equals(captureId) & t.userId.equals(userId),
    );

    final collection = await Collection.db.findFirstRow(
      session,
      where: (t) => t.id.equals(collectionId) & t.userId.equals(userId),
    );

    if (capture == null || collection == null) {
      return false;
    }

    // Check if already in collection
    final existing = await CaptureCollection.db.findFirstRow(
      session,
      where: (t) =>
          t.captureId.equals(captureId) & t.collectionId.equals(collectionId),
    );

    if (existing != null) {
      return true; // Already exists
    }

    // Add to collection
    final captureCollection = CaptureCollection(
      captureId: captureId,
      collectionId: collectionId,
      addedAt: DateTime.now(),
    );

    await CaptureCollection.db.insertRow(session, captureCollection);

    // Update collection cover image if not set
    if (collection.coverImageUrl == null && capture.thumbnailUrl != null) {
      collection.coverImageUrl = capture.thumbnailUrl;
      await Collection.db.updateRow(session, collection);
    }

    return true;
  }

  /// Remove a capture from a collection
  Future<bool> removeCaptureFromCollection(
    Session session,
    int captureId,
    int collectionId,
  ) async {
    final userId = await _getUserId(session);

    // Verify user owns the collection
    final collection = await Collection.db.findFirstRow(
      session,
      where: (t) => t.id.equals(collectionId) & t.userId.equals(userId),
    );

    if (collection == null) {
      return false;
    }

    final deleted = await CaptureCollection.db.deleteWhere(
      session,
      where: (t) =>
          t.captureId.equals(captureId) & t.collectionId.equals(collectionId),
    );

    return deleted.isNotEmpty;
  }

  /// Update collection details
  Future<Collection?> updateCollection(
    Session session,
    int collectionId, {
    String? name,
    String? description,
  }) async {
    final userId = await _getUserId(session);

    final collection = await Collection.db.findFirstRow(
      session,
      where: (t) => t.id.equals(collectionId) & t.userId.equals(userId),
    );

    if (collection == null) {
      return null;
    }

    if (name != null) {
      collection.name = name;
    }
    if (description != null) {
      collection.description = description;
    }

    return await Collection.db.updateRow(session, collection);
  }

  /// Delete a collection
  Future<bool> deleteCollection(Session session, int collectionId) async {
    final userId = await _getUserId(session);

    final collection = await Collection.db.findFirstRow(
      session,
      where: (t) => t.id.equals(collectionId) & t.userId.equals(userId),
    );

    if (collection == null) {
      return false;
    }

    // Remove all capture associations
    await CaptureCollection.db.deleteWhere(
      session,
      where: (t) => t.collectionId.equals(collectionId),
    );

    // Delete collection
    await Collection.db.deleteRow(session, collection);

    return true;
  }

  /// Helper to get user ID from session
  Future<int> _getUserId(Session session) async {
    final authInfo = await session.authenticated;
    if (authInfo == null) {
      return 1; // Demo mode
    }
    return authInfo.userId;
  }
}
